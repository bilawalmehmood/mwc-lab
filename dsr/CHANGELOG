13/06 	:: added bank.h & bank.cc. 
      	:: added dsr/bank.o to the OBJ_CC in ~ns-2.29/Makefile
	:: added #include "bank.h" in dsragent.h
	:: added myBank object to dsragent.h
	:: added constructor for bank in dsragent.cc line 340
	:: added code in handleForwarding(SRPacket &p) in dsragent.cc to 
	   check the bank balance of the node requesting forwarding and 
	   act appropriately approx line 931
	:: added function get_prev_addr in hdr_sr.h 

14/06	:: disabled flowstate in dsragent.cc by setting bool 
	   dsragent_enable_flowstate = false. Bank code now works properly.
	:: added monitor.cc & monitor.h
	:: added dsr/monitor.o to the OBJ_CC in ~ns-2.29/Makefile
	:: added #include "monitor.h" in dsragent.h
	:: added myMonitor object to dsragent.h
	:: added constructor for monitor in dsragent.cc line 340
	:: added code in dsragent.cc in tap() function to call the monitor when
	   a packet is overheard to check if it is one we sent and take
	   appropriate action, around line 2000
	:: added code in dsragent.cc sendOutPacketWithRoute() function to
	   cache a packet when it is sent, approx line 1300. Code not working
	   yet needs to be fixed.

15/06	:: fixed up previous glitch. everything seems to work by looking at the 	   
	   trace files generated by ns2, but my own debugging via print
	   statements doesnt seem to reliable, possibly due to ns2 weirdness?!

16/06	:: fixed up all bugs with monitor/bank, now works correctly and doesnt 
	   charge chips for route request/route reply. main problem was I was
	   i was using srh-> to get the next hop and that was screwing things up	   
	   by making nodes cache their own packets, so i used cmnh->next_hop(),
	   and also added another condition in sendOutPacketWithRoute() to stop
	   nodes from caching their own packets...seems when a node sends a 
	   packet to another node, it also receives that packet itself.
	:: Cruz made an excellent point that having cout print statements
	   all over the place made it hard to turn debugging on/off. I made an
	   "ocean.h" file which will contain all the specific parameter stuff
	   and also has debug entries for each of the ocean modules. Then where
	   I would print debug statements, I just use an #ifdef MODULENAME_DEBUG etc.
	   So to turn off debugging of a particular module, just comment out the 
	   #define MODULENAME_DEBUG entry in "ocean.h", ./clean, and make again.

19/06	:: added an extra condition to handleForwarding() in dsragent.cc to not
	   charge a node credit if it is not sending its own traffic, but forwarding
	   for another node. Consider 4 nodes: A   B   C   D. A wishes to send to D
	   through A->B->C->D. C will not charge B since B is forwarding A's traffic.
	   However, B will still give C chips for forwarding A's traffic. The logic follows
	   that since C forwards A's traffic, A will continue to use this route and hence
	   give B more opportunity to earn chips from A, so B will 'give' C chips for 
	   forwarding so B can in turn earn more chips from A. The only node which spends
	   chips is A, the creator of the packet.
	:: added checkPacketCache() method in monitor, which checks the cached packets for
	   a given node address to see if they have timed out. This check was previously
	   done inside the handleTap() method, however now a call is made in addPacketToCache()
	   to checkPacketCache(), so every time we send a packet to a node and go to cache that
	   packet, we check any other packets we have cached for that node to see if they
	   have timed out.
	:: added banktimer.h & banktimer.cc which periodically increments chip count of a 
	   node's neighbours.
	:: added method definitions used by banktimer.h in dsragent.h approx line 300.
	:: added method implementations used by banktimer.h in dsragent.cc near EOF.
	:: added "banktimer.o" to OBJ_CC variable in ~ns-2.29/Makefile
	:: added banktimer section in "ocean.h" with appropriate parameters
	:: added incAllEntries() method in "bank.h" used by banktimer
	:: added call to start timer in dsragent.cc method command() approx line 470
	:: couldnt compile because of cyclic dependencies between dsragent.h and banktimer.h
	   which were extremely bizarre and could not be resolved via forward declarations.
	:: so I deleted banktimer.h and banktimer.cc and defined the BankTimer class inside
	   dsragent.h and implemented its expire() method inside dsragent.cc

*** FINISHED PART 1: Monitor + Chip Economy ***

26/06	:: implemented optimistic/pessimistic economy scheme, added a define in ocean.h for it,
	   and some code in monitor.cc addPacketToCache() and handleTap().
	:: expanded BankEntry to contain a rating representing node behaviour, a count of the
	   # of packets a given node has forwarded for us, and a count of the # of packets we
	   have forwarded for that given node. Added methods & code to bank.h & bank.cc to
	   implement this.
	:: added a list of node addresses in monitor.h to represent the list of faulty nodes.
	:: added methods in monitor.h && monitor.cc return a nodes rating, add and remove nodes
	   from the faulty list, check if a node is contained in the faulty list, and register 
	   positive and negative events against a given node.
	:: a problem I had to solve: consider A->B->C, A sends to C through B. Eventually A will
	   run out of credits with B, and B will drop A's packets. Now A's monitor will 
	   execute negative events against B since A's cached packets will timeout as B wont send them.
	   However A doesn't know if B is dropping because he is being nasty, or because A has run out
	   of credits with B. This problem was not solved in the OCEAN paper. My solution: keep a
	   counter of #packets we forward for B, and the #packets B forwards for us. When we execute a
	   negative event against B, only decrease B's reputation if we have forwarded for packets for B
	   than they have forwarded for us, and hence we MUST have some credit remaining with B.
	:: added a call to registerNegativeEvent() in monitor.cc method checkPacketCache(). This registers
	   a negative event against a node when packets send to that node timeout in the cache.
	:: added a call to registerPositiveEvent() in monitor.cc method handleTap(). This registers
	   a positive event against a node when we detect that node forwarding our traffic.
	:: added code in dsragent.cc method handleForwarding() line ~1015 to increase #packets we have
	   forwarded for another node when we do so.
	:: Socceroos are playing Italy tonight. GO AUSSIE AUSSIE AUSSIE!!!!!!!!!

27/06	:: Italy won :-/
	:: added a list of node addresses into hdr_sr.h and method to get the list and append new
	   entries to it. This list represents the list of faulty nodes which the sender of the RREQ
	   packet does not want its traffic routed through.
	:: added code in dsragent.cc handleRouteRequest() approx line 1070 to check the faulty list
	   within the sr packet and treat it accordingly.
	:: added code in dsragent.cc sendOutPacketWithRoute() approx line 1522 to check if the packet
	   being sent is a route-request, and if so to append the local faulty list to the packet's
	   faulty list.
	:: added code in dsragent.cc acceptRouteReply() approx line 1843 to only accept a route reply
	   if the path does not contain any nodes in that node's faulty list
	:: added two boolean variables to dsragent.h, isSelfish and isMalicious. Also added some
	   necessary imports for file i/o.
	:: added method isMaliciousOrSelfish() to dsragent.h and implementation in dsragent.cc, and call
	   to this method in command() in dsragent.cc. This method just reads in a line
	   extracted from the "nodes.info" file and returns true if the current node's net_id is in the
	   selfish or malicious group (depending on if it was passed the selfish or malicious line
	   from the file).

28/06	:: added code in dsragent.cc handleForwarding() to implement malicious node behaviour as described
	   in NOTES. Also fixed a small logic error '>' instead of '<' in monitor.cc registerNegativeEvent().
	:: malicious node behaviour now works correctly, as does detection of this type of behaviour.
	:: added code in dsragent.cc handleForwarding() to implement selfish node behaviour of dropping
	   route-reply packets.
	:: added code in dsragent.cc handleRouteRequest() to implement selfish node behaviour of dropping
	   route-request packets.
	:: added routecache.h as an include in monitor.h, changed constructor of monitor to take a pointer
	   to the route_cache, and changed the DSRAgent() constructor in dsragent.cc to pass the extra
	   parameter to the monitor.
	:: added method deleteRoute(nsaddr_t) to classes defined in mobicache.cc and to interface in routecache.h.
	   This method will delete any routes containing the node passed in as arguement from the route cache.
	   also added "ocean.h" as an import in mobicache.cc, to enable debug printing if required.
	:: changed the monitor constructor in monitor.h to take in a pointer to a pointer to this node's route
	   cache. Added code to addNodeToFaultyList() in monitor.cc to call deleteRoute() with the address of
	   the faulty node. This will delete routes from the cache which contain faulty nodes, and force
	   the current node to perform RREQ again to find a route not containing faulty nodes. See test6
	   for an illustration of this working.

29/06	:: added code in dsragent.cc handleForwarding() to drop (not forward) traffic from nodes present
	   in a given node's faulty list.
	:: changed a small bug in dsragent.cc handleRouteRequest(), was checking the packet's embedded faulty
	   list against the nodes within the eoute, but should have been checking the node's faulty list
	   against the nodes within the route instead! So now a node will correctly drop a RREQ packet if
	   any nodes in it's faulty list are also in that packet's route.

24/07	:: added a bool called isFaulty in dsragent.h, and a method called setFaultyStatus() and one called
	   getFaultyStatus().
	:: created a queue class in "dsr/queue.h".
	:: created a FaultyTimePeriod class in dsragent.h which stores two ints representing the start
	   and end times of a faulty period
	:: created a FaultyTimer class in dsragent.h. This class will maintain a queue of FaultyTimePeriod
	   classes which enable it to turn faulty status on/off at the appropriate time.
	:: added a method resetFaultyTimer() in dsragent.h which resets that agent's faulty timer. 
	:: added in extra code in dsragent.cc commmand() to parse the "nodes.info" file and extract
	   faulty node information, and to start the faultyTimer.
	:: added code in dsragent.cc handleForwarding() to drop all packets if node is faulty
	:: added code in dsragent.cc handleRouteRequest() to drop all RREQ packets if node is faulty

25/07	:: changed logic error in monitor.cc function registerNegativeEvent(), to make it register a
	   negative event if myForwardingCount >= theirForwardingCount OR if we still have credit with
	   them left over from the initial amount.

26/07	:: fixed huge bug where when a node was set to faulty for a while then came back, the scheduler would
	   cycle through dsragent.cc's sendPacketWithRoute() many times, but sending each packet with an increased
	   sending delay. So I added a time paramaeter to monitor.h's addPacketToCache(), representing the time
	   when the packet is actually going to be sent. This prevented the problem where it looked like 60+ packets
	   were being sent at the exact moment in time, since the delay != 0 even though it usually == 0.
	:: changed incAllEntries() method in bank.cc to not regularly increment the bank balance of nodes
	   on our faulty list.
	:: changed BankTimer::expire() in dsragent.cc to make faulty nodes bank timer not work as they are faulty!





